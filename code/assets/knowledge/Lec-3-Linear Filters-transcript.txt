SPEAKER 0
Iowa. Welcome back to Introduction to Image Processing. Today's lecture we're going to cover on Linear is this SB? So today's outcomes is we've got and edify convolution mean filtering and noise and lastly Gaussian filtering. Let's begin our exploration of linear fields by looking at convolution mean filtering and noise. In the last lecture, you introduced two intensity transfer. Now to better understand the concept, the following diagram was used. Now to understand spatial filtering. We're going to reuse the same diagram here. Now we have two images. One of the source image. One is a target image. Now, in order for us to get the target image, we're going to perform some form of manipulation to the source pixel and surrounding the surrounding. It's what we call a window. It's a local processing base on the source pixel being at its centre. Okay. Now, something that everybody should be very, very clear about is when we talk about spatial, we're talking about space. So the space around the given pixel in this instance, the source pixel shown in green. Why do we perform special filtering? Well, that's a question that many of you might be asking. Intensely transformed read affects only a small pixel. Your power is limited. Processes, restrict it to a small, compact area, have access to more information, but are still likely to consider a single object. So the best illumination method. We know that images are spatially organised data structures, many important attributes very slowly across the image for object, identity, beauty, service, orientation, colour and illumination. Now let's look at now. Noise here is defined as small errors in image value. Now it's imperfect. Perfects, introduced noise, nice image compression methods are lossy. Repeat that. Coding and coding and nuts. Now noise is often modal as additive. So recorded value equals true value plus random noise value. And you can see from this diagram here an original image in that if you can see the G bank, it's not as clear as the original image. And that is because night has been introduced to the jetpack. And when you perform the difference between the two and in homes, you can literally see a lot of the noise appear in the difference image. One of the famous noise type is called Gaussian noise. In general, census often give a measurement a little of the true value. On average, they give the right value, but they tend to give values near the right value rather than far from it. So how do we perform this in a structured manner? We model this with a Gaussian. So with a Gaussian, we know that the mean is zero. Therefore, the variances will indicate how much noise there is. The level of the noise is related to the housing parameter. When implemented using the mathematical equation in the previous slide, we can control the amount of noise appearing in the image and this is shown in image two, three, four from the left images with varying degree of Gaussian noise and it. Now let's look at noise reduction. If you have multiple images taking the mean value, each pixel will reduce noise. We know that noisy rendering added to each value mean value and it is zero. If you average a set of estimates of the same pixel, the random noise values will be cancel out. As shown in the example below. Now, given only a single image averaging over a local region, would have a similar thing, would you think? Let's put it this example. You have a tree by tree we know whereby you average the value in that tree by tree. You should get a value of 42. Ideally, we would choose the region to only include pixel. They should have the same value before we need a special filter. Spatial filtering, also known as convolution. But many filters follow a similar pattern, multiplying each image value by a corresponding filter entry. In some meet the result. Now the description may sound a bit hard to comprehend, so let's put this into a diagram for easy understanding. To get the result on your right, we've been overlay the filter window from on the left over the picture window in the middle. Now, just to point this out, the filter with another picture window had the same dimension. A tree by tree kernel. Okay, so we're going to overlay the values from the filter window over the picture window, and we're going to multiply its values. Okay. Now, this will give us a total of nine different values each for each box, and we will sum up that result, giving us the output for the middle picture window, which is p x. Y. Now let's put this into a working problem. Okay. Now, filtering more generally with a filter with radius R here represented as a tree by tree or a five by five k. Now p x y is the original image value x. Y. P complement x. Y is the new image value and x y. So in order for you to get a p complement x y, you need apply this mathematical formula here. Now, many, though not all field does work this way. One example be the mean filter. Now, this slide shows you the output after applying the mean filter. Now, the image on the upper left is the original, whereas the image on the upper right is the Gaussian. The two image at the bottom, left and right respectively. Are output generated from a plane mean filter. No key points to remember. Spatial filters operate on local image region. Many can be formulated as convolution with a suitable mask. Example. Tree by tree. Five by seven. Seven, seven, nine, nine, nine. 11 by 11. And so forth. One thing to take note of the higher the mass is, the more blur the image output will become. Noise reduction via mean filtering is a classic example. Now let's look at Gaza. Infiltrate. One of my favourite. Goes in, filled this convolution with a mosque whose suites are determined by a 2D Gaussian function. How you weight is given to pixel near the source pixel meaning the source be the mean. These are more likely to lie on the same object as the source pixel. Of course, the formula you see here is the formulation only used for a Gaussian filter. Let's look at discrete filters. The Gaussian extends infinitely in all directions, but we want to process just a local window has a volume underneath it of one which we want to maintain so we can approximate the Gaussian with a discrete filter. We restrict ourself to a square window and sample the Gaussian function. We normalise the result so that the filter entries at two one meaning 0 to 1. Let's put this into perspective in example. Suppose you want to use a five by five window to apply a garden filter with a small one. So the central the window has x equals two, Y equals zero. See the middle kernel of the five by five. We know we sample the doors in each point and we normalise it to make sure that it's under one. If you look at this five by five, you'll notice the middle of the five by five has the highest Gaussian value because it is the mean. But if you move further away from it, if you move further away from even looking at this plot here where I'm putting in the red pen, you can see that all of this has a value which is lower. So as you move further away from the mean, as you can see with the red dot in these respective boxes, you can see that the value is becoming smaller or equal to zero, whereas value is nearer to the mean. As you can see here, I'm putting it in a line here. You can see the value is not that far away from the mean is quite big in its value. So to see that this particular pixel surrounding the middle on the centre, the window has similar characteristics to the centre of the window. No. Then the question comes into my were using the filter. Hmm. How big should the filter we know be with Gaussian filters? It depends on the variance under the Gaussian code. 98% of the area lies within two sigma of the mean in the mean is in the middle here. Two sigma will be to signal to the left. Months to the right. Okay. Oh, Fill the width of five variants. If more than 98% of the value we want. So a five sigma should be suffice. Now they might. If the window is much more larger, you might get a result output, which is blue. We can see here from the image on the bottom right of the slide. This slide shows you the result of playing Gaussian using different windows. So you have the original image of the upper left and you have Gaussian output on the upper right, bottom left and bottom right respectively. No guardian can be implemented in another way as well. Here we call separable to this. Not the Gaza filter is separable. So a 2D go is equivalent to to one. Be Gaussian first and filter with a horizontal Gaussian. Then with a vertical Gaussian. Now, why would we want to use separable filters? The separate that filter is separable is more efficient. No. Look at this from the point of view of the processes. Shall we? By hemming in by an image within my info that it's going to contribute to a very, very big, big old mutation operation. If you're using the Gaussian filter as it is. However, if we are looking at separating its filter into two and by one filters and applying it to the same end by an image, it will affect the orientation greatly. So that's why by performing several filters, we are also improving on the operation of it. So take this for example. You have a 600 by 400 image in a five by five field applied directly takes around 6 million operations. Now, using separable filters takes around 2.4 million, less than half as many. Now few key parts to remember. Light mean filtering and Gaussian smoothing can be used to remove additive noise. Gaussian smoothing and flush sizes peaks along in the source pixel where it is more likely image properties are fixed. Gorgeous, moving, inseparable. And so more efficient. Now to this lecture we have covered convolution mean filtering and we now have a better understanding what noises about. We also look at Gaussian filtering in some detail. As always, if you have any question, you know where to find me. With that brings us to the end to today's lecture. Next week, we're going to cover a nonlinear filtering and thresholding. Till then, everyone, take care. Stay safe and I'll see you soon, Jess.
